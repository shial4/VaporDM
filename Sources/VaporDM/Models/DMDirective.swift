//
//  DMDirective.swift
//  VaporDM
//
//  Created by Shial on 19/04/2017.
//
//

import Foundation
import Vapor
import Fluent

/// Fluent Model representing message sent from user to chat room.
public final class DMDirective {
    public var exists = false
    
    /// Models unique id
    public var id: Node?
    /// Chat room unique id
    public var room: Node?
    /// Owner/Sender unique id
    public var owner: Node?
    
    /// Model key string to read/write from Node objects
    struct Constants {
        static let id = "id"
        static let room = "roomid"
        static let owner = "ownerid"
        static let created = "created"
        static let updated = "updated"
        static let message = "message"
    }
    
    /// Text message which was sent
    public var message: String
    /// Time identification
    public var time: DMTimeIdentification = DMTimeIdentification()
    
    /// Create Direct Message object
    ///
    /// - Parameters:
    ///   - message: message string
    ///   - system: system flag indicate if this message was generated by system. Default value is false
    /// - Throws: Error if something goes wrong
    public init(message: String) throws {
        self.message = message
    }
    
    public init(node: Node, in context: Context) throws {
        id = try? node.extract(Constants.id)
        room = try node.extract(Constants.room)
        owner = try node.extract(Constants.owner)
        time.created = try node.extract(Constants.created,
                                        transform: Date.init(timeIntervalSince1970:))
        time.updated = try node.extract(Constants.updated,
                                        transform: Date.init(timeIntervalSince1970:))
        message = try node.extract(Constants.message)
    }
}

extension DMDirective: Model {
    public func makeNode(context: Context) throws -> Node {
        var node: [String: Node] = [:]
        node[Constants.id] = id
        node[Constants.room] = room
        node[Constants.owner] = owner
        node[Constants.message] = message.makeNode()
        node[Constants.created] = time.created.timeIntervalSince1970.makeNode()
        node[Constants.updated] = time.updated.timeIntervalSince1970.makeNode()
        return try node.makeNode()
    }
}

extension DMDirective: Preparation {
    public static func prepare(_ database: Database) throws {
        try database.create(DMDirective.entity, closure: { (directive) in
            directive.id()
            directive.parent(idKey: Constants.room, optional: false)
            directive.parent(idKey: Constants.owner, optional: false)
            directive.string(Constants.message)
            directive.double(Constants.created)
            directive.double(Constants.updated)
        })
    }
    
    public static func revert(_ database: Database) throws {
        try database.delete(DMDirective.entity)
    }
}

extension DMDirective {
    /// Return chat room object for this message
    ///
    /// - Returns: chat room
    /// - Throws: Error if something goes wrong
    public func getRoom() throws -> DMRoom? {
        return try parent(room).first()
    }
    /// Return message owner
    ///
    /// - Returns: owner
    /// - Throws: Error if something goes wrong
    public func getOwner<T:DMUser>() throws -> T? {
        return try parent(owner).first()
    }
}
